<!DOCTYPE html>
<html>
<head>
    <title>wgertler | Tumbling Down the Rabbit Hole</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="author" content="William Gertler">
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="css/kube.min.css" />
    <link rel="stylesheet" href="css/font-awesome.min.css" />
    <link rel="stylesheet" href="css/custom.min.css" />
    <link rel="icon"       href="img/favicon.png" />
    <link href="http://fonts.googleapis.com/css?family=Lato:400,700" rel="stylesheet" type="text/css">
    <link href="http://fonts.googleapis.com/css?family=Open+Sans:400,700" rel="stylesheet" type="text/css">

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<script type="text/javascript" async src="MathJax-master/MathJax.js?config=TeX-AMS_CHTML-full"></script>

</head>
<body>
	<!-- Navigation -->
	<div class="main-nav">
		<div class="container">
			<header class="group top-nav">
				<nav class="navbar logo-w navbar-left" >
					<a class="logo" href="index.html">wgertler</a>
				</nav>
				<div class="navigation-toggle" data-tools="navigation-toggle" data-target="#navbar-1">
				    <span class="logo">wgertler</span>
				</div>
			    <nav id="navbar-1" class="navbar item-nav navbar-right">
				    <ul>
				        <li><a href="index.html">Home</a></li>
				        <li><a href="about.html">About</a></li>
				        <li><a href="archive.html">Archive</a></li>
				        <li><a href="contact.html">Contact</a></li>
				    </ul>
				</nav>
			</header>
		</div>
	</div>
	
	<!-- Content -->
	<div class="content">
		<div class="container">

			<!-- Post -->
			<div class="post">
				<!-- Heading -->
				<a>
					<h1>Wow being sick sucks</h1>
				</a>
				<hr>
				<div class="in-content">

					<p>
						Holy hell was I ever sick. From about May 22nd to maybe this past Sunday, I was really just floored. 
						Tonsillitis is no joke. I'd never want to catch that chronically. While I was under, though, I managed 
						to put a dent in some books and papers; Nielsen and Chuang, Artin, and John Watrous's new book on QI 
						theory- which was definitely written for CS people. Still pretty good! Thinking I might try to go back to 
						one of my old jobs instead of just free-forming my studies until the fall. That's all that's really been
						going on lately in a professional way. Apart from that, I went to Toronto and met up with some of the family
						this past week- Toronto island is actually really nice! I should really get to the city more often- I hardly 
						know it at all, it's a little tricky to keep telling people it's my hometown when the only neighbourhood I know
						even vaguely well is the kind of Palmerston-St. George-Kensington triangle.  
					</p>

				</div>
			</div>

			<!-- Post -->
			<div class="post">
				<!-- Heading -->
				<a>
					<h1>Fast-Talking Quantum Algorithms</h1>
				</a>
				<hr>
				<div class="in-content">
			
					<p>
						Thursday last I gave a really fast primer on quantum mechanics (with an eye towards 
						quantum computing) for the university's computer science club. Computer science majors
						are a technically inclined audience, but (at least at Waterloo) have no mandatory training
						in fundamental physics. This perspective lays an interesting challenge! How do you motivate 
						a field for an audience with a wholly different set of interests? I tried starting with the 
						mathematics as a common foundation, thinking that this would lead to a more accessible entry-
						what I found instead was that letting the students ask questions about the physics, they 
						managed to get the principles more clearly!   
					</p>
			

					<p>
						I'm gonna write out the essence of the talk here. It's pretty entry-level stuff, I think you
						could find most of what I laid out in the first two chapters of Nielsen and Chuang. I focused on 
						two physical properties of quantum states and their interactions- superposition and entanglement.
						Both of these properties yield interesting results when you apply them to problems that are 
						computational in nature!
					</p>

					<p>
						First up is to talk superposition: Superposition is a fundamental principle of quantum 
						mechanics. That is to say, it is an observed phenomena that two quantum states can be 
						"overlaid" in a way to create a new state, in a way quite analogous to the way macroscopic waves
						overlay- the associated constructive and destructive interference included. In fact, the mathematical 
						representations of dynamics of quantum systems are wavelike in nature, reflecting this. We call the 
						principle of superposition one of the "postulates" of quantum mechanics. 
					</p>
					
					<p>
						In a mathematical way, we need to talk about the way that a quantum state "exists" mathematically speaking.
						We express quantum mechanical systems and states as elements (generally vectors) of a multi-dimensional 
						(even infinitely dimensional), complex-valued 
						<a href="https://en.wikipedia.org/wiki/Hilbert_space" target="_blank">"Hilbert Space"</a>. 
						We take that the basis of this Hilbert space is orthonormal for a few reasons- firstly, in quantum mechanics, 
						we cannot distinguish between the measurement outcomes of non-orthogonal systems reliably. Picking an orthogonal 
						basis in which to operate makes the construction of reliably measurable states simpler. It also has the added benefit
						of making many of our calculations very simple- if you're taking the inner product between any two non-equal elements, 
						it's just zero! As for normality, we use normalized vectors so that we can keep our notions and parallels with 
						probabilistic results, and normality conditions lead to natural weightings on expected measurement results. 
					</p>

					<p>
						Concretely, taking some state $$\ket{\psi} = \alpha\ket{0}+\beta\ket{1}$$ $$\alpha^2+\beta^2 = 1$$
						and realizing that in our "computational basis" our vectors are represented as $$\ket{0} = 
							\begin{pmatrix} 
								1 \\
								0\\
							\end{pmatrix}, \, 
						\ket{1} = 
							\begin{pmatrix} 
								0 \\ 
								1 \\ 
						\end{pmatrix}$$

						we see that the state $\ket{\psi}$ is in fact normal upon the evaluation of the inner product. We say that 
						$\ket{\psi}$ is in a "superposition" of $\ket{0}$ and $\ket{1}$, as it's a linear combination of the two basis
						parameters. This is in clear analog of classical superpositions of waves, their waiting, and their position in space.
						A lot of the advantage that we're availed in quantum computing comes from the idea that the parameters 
						$\alpha$ and $\beta$ are allowed to take any complex values, so long as they fulfill the above condition. The way That
						a collapse of a superposition happens is with a "measurement"- which essentially selects either of the states with a 
						probability of the squares of their respective coefficients. This is reflected in 
						<a href="https://en.wikipedia.org/wiki/Born_rule", target = "_blank">Born's Rule</a> and expressed mathematically
						with the explanation that quantum state vectors may be represented as belonging to the space $L^2(\mathbb{R})$
						with a Lebesgue measure of 1. The probability amplitudes of each potential result may be found to be
						$$c_n^2$$ 
						with 
						$$c_n = \braket{\psi_n}{\phi_n} = \int_{-\infty}^{\infty}\psi^{*}_{n}\phi_{n}dx.$$
						Again, making sure that the normality condition is held. Effectively, we should be finding results 
						saying the probability of measuring a certain outcome is the square of the coefficient associated with that 
						state- though this may change after particular operations on our state vector. 
					</p>

					<p>
						Next stop on our road to understanding in entanglement. Entanglement is a feature of quantum mechanics that has 
						a reputation for being fairly unintuitive- not the least reason for this being that associated terms lend to the 
						notion that entangled particles allow superluminal communication- which is a very big problem if you're a 
						German named Albert. At it's core, entanglement is an induced relationship between certain observable parameters of
						quantum systems- spin and polarization requiring special mention as the "canonical" examples. What plagued the physics
						community in the late 1930's was the indication that entangled states violated a principle called "local realism" which 
						was a long-standing notion of classical mechanics. This violation is what Einstein, as well as his collaborators 
						Podolsky and Rosen, had the most trouble accepting. However, it was shown experimentally that entangled states do in fact
						violate local realism, more or less putting the argument to rest. The result of decoherence is known immediately by the 
						states in question, though the knowledge of the result is not. There is no violation of special relativity, despite what
						the terminology would lead the naive to think. 
					</p>

					<p>
						In mathematical terms, lets say we have two state vectors from two different Hilbert spaces, $\mathcal{H}_a$ and 
						$\mathcal{H}_b$.  Then the interaction of these two states is going to exist in the "product space" 
						$$\mathcal{H}_a \otimes \mathcal{H}_b.$$ Now, some vectors may exist in this product space that may be written out 
						simply as kronecker products between vectors from each state themselves, say 
						$$\ket{\phi_a}\otimes\ket{\psi_b}.$$ We call states like these "separable", and they are not entangled.
						However, there are plenty of new state vectors that do exist in the product space and are not separable. For 
						example, the state $$\frac{\ket{0}_a\ket{0}_b+\ket{1}_a\ket{1}_b}{\sqrt{2}}$$ is not separable, but surely exists in some product state.
						We call these states entangled because it is impossible to say which part of the state came from what Hilbert space. 
						These entangled may be measured partially such that you learn both results without having to measure both states 
						individually- in the above example, if Alice measures her state to be 0, we know Bob's state is also 0. 
						Entanglement doesn't last forever, though- once the entangled states are measured, they decohere and are no longer
						correlated. 
					</p>

					<p>
						So what does any of this physics stuff have to do with computing? It turns out that there are some algorithms that, if 
						implemented on the appropriate hardware, produce a significant speed-up over classical methods of computing when using
						these properties! 
					</p>

					<p>
						Personally, I find that "quantum teleportation" is an algorithm that is sufficiently simple to explain to the interested
						layperson, but with a result interesting enough and understandable enough to be appreciated. Let's dive in!
					</p>

					<p>
						First, it is important to make explicit our vernacular. A "qubit" is most easily understood in the same way a classical bit is,
						but with the ability to conform to the conventions of quantum mechanics. Most intuitively, a single qubit is a two-level system
						which may exist in superposition but must collapse into one of its mutually-exclusive states: $\ket{0}$ or $\ket{1}$. There are 
						many different models for the physical realization of a qubit, and to list and explain them would be a post all to itself (and 
						frankly a little outside my particular area of interest at the moment). You can put a bunch of qubits together, and you can entangle
						them with each other. 
					</p>

					<p>
						Now lets set the scene. Let us suppose that Alice and Bob are an adventuring duo who share a mutual interest in information
						theory. Sometime before the events of today's adventure, they decided to, as good enthusiasts, prepare a bell state and
						share it. For simplicity, say they chose the state $$\ket{\beta_{00}}=\frac{\ket{0}_a\ket{0}_b+\ket{1}_a\ket{1}_b}{\sqrt{2}}.$$
						Now say, in the course of their adventuring, that they get separated. For reasons of emotional engagement and authorial laziness,
						it is absolutely necessary that Alice be able to get a particular quantum state, $\ket{a}=\alpha\ket{0}+\beta\ket{1}$, to Bob
						lest they suffer an absurd level of dismay at the hands of some nefarious entity. The only tool they have to save the day is their 
						knowledge of quantum mechanics and a few bits of classical information (like a phone call or something). 
					</p>

					<p>
						Now, the odds look pretty bad. They can't physically meet, and they can only share classical bits. But due to the nature of superposition,
						there's literally an infinite amount of information that would need to be shared between the two to fully characterie the quantum state (say
						if alpha/beta are transcendental numbers). Not only that, but they only have a single qubit to share! Can they do it?  
					</p>

					<p>
						You better believe it. Here's the scheme - 
					</p>

					<p style = "text-align:center;">
						<img src="img/quanttelep.png" alt="Circuit diagram for quantum teleportation" class="center">
					</p>

					<p>
						In this diagram, $\ket{b}$ and  $\ket{c}$ are the entangled qubits making up the bell state, the former belonging to Alice
						and the latter to Bob. Word to the wise: circuit diagrams are read from left to right and top-down, but the operations
						performed by the gates are still applied on the left of the input bits unless otherwise specified. 
					</p>

					<p>
						Alice starts by interacting $\ket{a}$ with her half of the entangled pair: this results in 
						$$\ket{\psi_0} = \frac{1}{\sqrt{2}}\biggl[\alpha \ket{0}(\ket{00}+\ket{11)} + \beta\ket{1}(\ket{00}+\ket{11)}\biggr].$$
					</p>

					<p>
						The next operation is a controlled-not: The data register of the first qubit is read in. If it is equal to one, it flips the 
						bit on the second line, in this case. We get 
						$$\ket{\psi_1} = \frac{1}{\sqrt{2}}\biggl[\alpha \ket{0}(\ket{00}+\ket{11)} + \beta\ket{1}(\ket{10}+\ket{01)}\biggr].$$

					</p>

					<p>
						Next up is a Hadamard gate, being applied on the first qubit. The Hadamard (in two dimensions) gate takes the form
						$$H = \frac{1}{\sqrt{2}} 
						\begin{pmatrix}
						1 & 1 \\
						1 & -1 \\
						\end{pmatrix}
						$$ 
						and when applied to the first qubit yields

						$$\ket{\psi_2} = \frac{1}{2}\biggl[\alpha (\ket{0}+\ket{1})(\ket{00}+\ket{11)} + \beta(\ket{0}-\ket{1})(\ket{10}+\ket{01)}\biggr].$$
						Knowing that the Kronecker product is associative, we can re-arrange this result after distributing all the products. This recovers
						
							$$\ket{\psi_2} = \frac{1}{2}\biggl[\alpha \ket{00}(\alpha\ket{0}+\beta\ket{1}) + \ket{01}(\alpha\ket{1}+\beta\ket{0}) + \ket{10}(\alpha\ket{0}-\beta\ket{1}) + \ket{11}(\alpha\ket{1}\beta\ket{0})\biggr].$$

					</p>

					<p>
						As we can see, each of Bob's possible qubits corresponds to one of Alice's measurement results. Alice must measure her qubit, and tell Bob what she recovered.
						If she gets $\ket{00}$, Bob needs not send his qubit through post-processing as it is already in the original state $\ket{a}$. 
						However, should she measure another result, say $\ket{01}$, then Bob must put his qubit through a "NOT" gate or $X$-gate, which flips the bits, and is represented by
						$$ X = 
						\begin{pmatrix} 
						0 & 1 \\ 
						1 & 0 \\ 
						\end{pmatrix} 
						$$

						Similarly, if Alice measures $\ket{10}$, Bob must use a $Z$-gate to flip the sign of the second qubit:
						$$ Z = 
						\begin{pmatrix} 
						1 & 0 \\ 
						0 & -1 \\ 
						\end{pmatrix}. $$

						And finally, if Alice recovers $\ket{11}$, Bob must first apply an $X$-gate and then a $Z$-gate.
						The mission was a success! 
					</p>
	
					<P>
						But quantum algorithms can do some more practical, more real-life things as well, some of which are cause for concern.
						<a href="https://en.wikipedia.org/wiki/Shor's_algorithm" , target="_blank">Shor's Algorithm</a> for example has the power to
						factor large products of prime numbers efficiently: a hard task on a classical computer, and a threat to common internet 
						protocol encryption schemes. But it's supposed that there will be algorithms that can things for good, like running 
						pharmacokinetic simulations to develop better drugs, or to do complicated protein folding problems and help physicians cure 
						diseases. It's hard to say what will happen, or if the tech will really go anywhere, but it's pretty exciting just to be around 
						researchers with such drive and energy, and such a young field in general. 
					</P>
				</div>
			</div>

			<!-- Post -->
			<div class="post">
				<!-- Heading -->
				<a>
					<h1>Update</h1>
				</a>
				<hr>
				<div class="in-content">
					
					<p>
						It's looking like I'm going to be sticking around KW, at least for the foreseeable future. 
						Nothing terribly concrete until the new semester starts in September, but for the now I'm gonna 
						bounce from group to group to group theory and try to catch up on the current state of the art. 
						Man, is there ever a gap in undergraduate education- Even now I'm still getting the hang of reading 
						research papers. We should have more workshops on this, or something. Even if it isn't vital for
						<i>everyone</i>, it's still really important for anyone continuing in research work. Anyway, in the
						mean time, I'm also doing some consulting work, but that's a little cloak-and-dagger, for the time 
						being. As for the site, I've updated the reading recommendations a little, but it's still kinda barren.
						That's gonna need some more work. 
					</p>

					<p>
						Still writing up this applied crypto paper- I'll post all about it and reveal my accomplice when we're 
						done (though it's liable to be some more time.) Today I've decided to refresh algebra- I'm plowing through 
						Artin's text right now. It's a little on the wordy side, but pretty much just enough to be clear. Not fluff, 
						rather elucidation. It's pretty self-contained too, which is a major plus for me, giving my fixation on 
						starting on page one instead of where what I'm immediately interested in starts. 
					</p>

					<p>
						A bunch of my friends have moved away by now, so while the summer semester is usually pretty empty, it's even 
						more barren here. But some friends from the coast are moving Ontario-way in the coming months, and I'm looking 
						forward to being able to see them. 
					</p>
				</div>
			</div>

			<!-- Post -->
			<div class="post">
				<!-- Heading -->
				<a>
					<h1>Dawdling in Number Theory</h1>
				</a>
				<hr>
				<div class="in-content">
			
					<p>
						A lot of the reason I read a particular textbook has to do with its portability. I've got a 
						lot of moving around to do over the course of the day. If I want to kill the commute time, 
						reading has always been my go-to. Reading on the bus is kinda nice, but if you've got a text
						that's a little too large, it can be prohibitive. Not to mention the fact that you've got to 
						carry it around all day. Fortunately, there are a plentitude of texts that fit <i>right in 
						your pocket!</i> The one I picked off the shelf today is called <i>Introduction to Elliptic
						Curves and Modular Forms</i>, by a guy named Neal Koblitz. He's a cryptographer at the 
						university of Washington, and an adjunct faculty member here at Waterloo.
					</p>
			
					<p>
						I don't actually know any number theory, though. So this book has been an adventure. I've
						had to brush up on some definitions, sit and ponder a few things. The first problem I worked 
						out today had to do with primitive Pythagorean triples, which is a 3-tuple of intergers 
						$(X,Y,Z)$ such that $X^2+Y^2=Z^2$, with none of the intergers sharing a common factor.
						We suppose that $a>b$ without loss of generality, and say that they're not both odd, 
						and relatively prime. The problem is to show that, given the relations 
					</p>

					<p>
						$$ X=a^2-b^2,\, Y=2ab,\, Z= a^2+b^2$$
					</p>

					<p>
						form a triple so-described, and that all primitive Pythagorean triples take this form. 
						Showing that this is formulation of $(X,Y,Z)$ is a triple is simple, all that's needed is to 
						recognize that these values fulfill the Pythagorean theorem. Showing that they form all 
						primitive solutions is a little trickier. Letting both $a$ and $b$ be even, we see that $Y$ 
						and $Z$ are no longer coprime. Similarly, if both $a$ and $b$ are odd, all $(X,Y,Z)$ become 
						even, and thus no two of them are coprime. Thus, we need one of $(a,b)$ to be odd, and the 
						other even.
					</p>

					<p>
						The reason we know <i>all</i> primitive triples are found this way is the most interesting 
						part. The easiest way to see it is to draw a picture:
					</p>
					
					<p style="text-align:center;">
						<img src="img/unit.png" alt="Unit Circle with chord from (-1,0) to (u,v) in first quadrant" class="center">
					</p>

					<p>
						Re-paramaterizing from $$ X=a^2-b^2,\, Y=2ab,\, Z= a^2+b^2$$ to $$u=\frac{X}{Z},\,v=\frac{Y}{Z}$$, 
						we see that following the Pythagorean theorem leads us to know that $u^2+v^2=1$, naturally leading 
						us to a parametrization of the unit circle. Cycling through the intergers for $a$ and $b$ gives us 
						all possible Pythagorean triples.
					</p>
				</div>
			</div>

			<!-- Post -->
			<div class="post">
				<!-- Heading -->
				<a>
					<h1>A Frivolous Theorem of the Natural Numbers</h1>
				</a>
				<hr>
				<div class="in-content">
		
					<p>
						Alright, check this out. I think this is pretty funny. 
					</p>
					<p>
						Theorem: Almost every natural number is really, really big. 
					</p>
					<p>
						Proof: Suppose we take some number $n \in \mathbb{N}$  to be a threshold of "really, really 
						big" such that if we add any number $k \in \mathbb{N}$ to $n$, the number $n+k$ is also 
						"really, really big" and if we subtract any number $m \in \mathbb{N}$ from $n$, the number 
						$n-m$ is not "really, really big". Then, since the naturals are bounded from below and 
						unbounded from above, we have finitely many numbers below $n$ and infinitely many numbers 
						above $n$. Thus, all but finitely many natural numbers are "really, really big".
					</p>

					<p align="right">

						$\it{Q.E.D.}$

					</p>

					<p>

						Note: recently, a nice math student told me what a "filter" was, so I'll probably have to 
						clean this post up a little bit. I'll put it on the to-do list. Future me can deal with that. 

					</p>

				</div>
			</div>
			<!-- /post -->

			<!-- Post -->
			<div class="post">
				<!-- Heading -->
				<a><h1>Your Signature, not your John Hancock: A Note on Conventions</h1></a>
				<hr>
				<div class="in-content">
					<p>
						The point of this post is two-fold: First, I've just tried to implement MathJax in the site, 
						and I'm gonna try to test it out. If you're seeing this, it probably worked. Secondly, I've 
						been thinking a lot about conventions in physics, how they're useful, when they're not, and 
						what we gain by thinking about them. In a more abstract sense, the line of thought leads 
						(or at least has lead me) to the unsurprising but important realization that the order in 
						which learn things can substantially effect our tastes, and not always benignly. 	
					</p>
					
					<p>
						So I've been taking a course called "Quantum Field Theory for Cosmology" at Perimeter this 
						semester. It's a spiritual successor to a course I took the previous semester, which focused 
						on general relativity. In both of these courses, we've got this thing called a "metric", 
						which is essentially a way of telling us how far away certain events are in spacetime. In 
						Minkowski (flat) spacetime, we've got two ways of representing the metric. In general 
						relativity and quantum gravity, the convention is: 

						$$
						\eta^{\mu \nu}= \eta_{\mu \nu} =

						\begin{pmatrix}
							-1 & 0 & 0 & 0 \\
							0 & 1 & 0 & 0 \\
							0 & 0 & 1 & 0 \\
							0 & 0 & 0 & 1 \\
						\end{pmatrix}
						$$

						and in quantum field theory and particle physics, the convention is

						$$
						\eta^{\mu \nu}= \eta_{\mu \nu}=

						\begin{pmatrix}
							1 & 0 & 0 & 0 \\
							0 & -1 & 0 & 0 \\
							0 & 0 & -1 & 0 \\
							0 & 0 & 0 & -1 \\
						\end{pmatrix} 
						$$
					</p>

					<p>
						It's important to note for the non-specialist that these will give you the same physics, 
						as long as you're consistent in your choice. I'll give an example: take the Lagrangian 
						density of a real scalar field-

						$$
						\mathcal{L} = \frac{1}{2}\eta_{\mu \nu}\partial_{\mu}\phi\partial_{\nu}\phi - 
						\frac{1}{2}m^2\phi^2
						$$

						This is going to look a little different depending on our choice of metric: in the first, 
						it's going to be 

						$$
						-\frac{1}{2}\dot{\phi}^2 + \frac{1}{2}(\nabla\phi)^2-\frac{1}{2}m^2\phi^2
						$$

						and in the second, 

						$$
						\frac{1}{2}\dot{\phi}^2 - \frac{1}{2}(\nabla\phi)^2-\frac{1}{2}m^2\phi^2
						$$

						Solving the equations of motion, 

						$$\frac{\partial\mathcal{L}}{\partial\phi} = -m^2\phi \quad , 
						\quad \frac{\partial\mathcal{L}}{\partial(\partial_{\mu}\phi)} 
						= (-\dot{\phi}, \nabla\phi)$$

						Very similarly, in the second metric, 

						$$\frac{\partial\mathcal{L}}{\partial\phi} = -m^2\phi \quad , 
						\quad \frac{\partial\mathcal{L}}{\partial(\partial_{\mu}\phi)} 
						= (\dot{\phi}, -\nabla\phi)$$

						These both lead to very similar Euler-Lagrange equations:

						$$\ddot{\phi} - \nabla^2\phi+m^2\phi = 0$$

						For the negative signature, or

						$$-\ddot{\phi} + \nabla^2\phi+m^2\phi = 0 $$

						for the positive. 

						These both lead to, in relativistic notation, identical reductions to what is termed the 
						Klein-Gordon equation:

						$$(\partial^{\mu}\partial_{\mu} + m^2)\phi = 0$$


						So they both work. I first learned the first one, and so in the tribal way that people tend 
						towards, I decided it was the best way to do things and that the other way wasn't as good. 
						But they both have their strengths and their weaknesses, but only really in the aspects that 
						become more obvious depending on the sign. For the (+,-,-,-) convention, you get timelike 
						4-vectors with positive magnitude. For (-,+,+,+), you keep familiar 3-d formalism. You also 
						don't have to worry about your determinant flipping in a generalized dimensionality case.  
						It's an aesthetic choice, and (as far as I can tell) nothing deper. I still prefer the first 
						one, but only because I'm used to it. I don't think that the other one is inferior anymore. 
					</p>

					<p>
						The point I'm trying to make, and I swear there is one, is that I've been thinking a lot 
						these past couple of days about how much of what we learn is stylistic in nature rather than 
						substantiative, and the interrelation of style and substance. No serious conclusions yet, but 
						I'm going to use this example as a reminder to be more open-minded about ways to frame 
						information, ways of knowing, and ways of understanding. 
					</p>

				</div>
			</div>
			<!-- /post -->
			
		</div>
	</div>

	<footer>
		<div class="container">
			<div class="units-row">
			    <div class="unit-100">
					<ul class="social list-flat right">
						<li><a href="mailto:will.gertler@gmail.com"><i class="fa fa-send"></i></a></li>
						<li><a href="http://twitter.com/swickrotation"><i class="fa fa-twitter"></i></a></li>
						<li><a href="https://www.linkedin.com/in/william-gertler-7a965375/"><i class="fa fa-linkedin"></i></a></li>
					</ul>
				</div>
			</div>
		</div>
	</footer>

	<!-- Javascript -->
	<script src="js/jquery.min.js"></script>
    <script src="js/kube.min.js"></script>
</body>
</html>