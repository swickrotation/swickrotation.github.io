<!DOCTYPE html>
<html>
<head>
    <title>wgertler | Tumbling Down the Rabbit Hole</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="author" content="William Gertler">
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="css/kube.min.css" />
    <link rel="stylesheet" href="css/font-awesome.min.css" />
    <link rel="stylesheet" href="css/custom.min.css" />
    <link rel="icon"       href="img/favicon.png" />
    <link href="http://fonts.googleapis.com/css?family=Lato:400,700" rel="stylesheet" type="text/css">
    <link href="http://fonts.googleapis.com/css?family=Open+Sans:400,700" rel="stylesheet" type="text/css">

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>
<script type="text/javascript" async src="MathJax-master/MathJax.js?config=TeX-AMS_CHTML-full"></script>
<script type="text/javascript" src="MathJax-master/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/javascript" src="MathJax-master/braket/braket.js"></script>

</head>
<body>
	<!-- Navigation -->
	<div class="main-nav">
		<div class="container">
			<header class="group top-nav">
				<nav class="navbar logo-w navbar-left" >
					<a class="logo" href="index.html">wgertler</a>
				</nav>
				<div class="navigation-toggle" data-tools="navigation-toggle" data-target="#navbar-1">
				    <span class="logo">wgertler</span>
				</div>
			    <nav id="navbar-1" class="navbar item-nav navbar-right">
				    <ul>
				        <li class="active"><a href="index.html">Home</a></li>
				        <li><a href="about.html">About</a></li>
				        <li><a href="archive.html">Archive</a></li>
				        <li><a href="contact.html">Contact</a></li>
				    </ul>
				</nav>
			</header>
		</div>
	</div>

	<!-- Introduction -->
	<div class="intro">
		<div class="container">
			<div class="units-row">
			    <div class="unit-10">
			    	<img class="img-intro" src="img/a1.png" alt="img/test.png">
			    </div>
			    <div class="unit-60">
			    	<p class="p-intro">Will is reading: Functional Analysis by A. Kolmogorov</p>
			    </div>
			</div>
		</div>
	</div>
	
	<!-- Content -->
	<div class="content">
		<div class="container">

			<!-- Post -->
			<div class="post">
				<!-- Heading -->
				<a>
<<<<<<< HEAD
					<h1>Random Number Generation: Quantum and Classical</h1>
				</a>
				<hr>
				<div class="in-content">
					<p>
						Happy new year! Hope you had a nice holiday and that 2019 is treating you well thus far, and that it continues to do so. After the past few years, I think the world could use a good one. Something interesting happened to me last year. My friend Tim, a software engineer and security consultant at <a href="https://chosenplaintext.ca">Chosen Plaintext</a> got tapped to evaluate a quantum random number generator. That required some physics background that he didn't have, so he called yours truly to lend a hand to the project! 
					</p>

					<p>
						Unfortunately, due to some circumstances outside of our control, the project was put on indefinite hiatus before we could really start. We did, however, get to have an excuse to spend some time together learning about some interesting technology- which I will describe here in broad strokes shortly. But first, it's helpful to have some idea what we want random numbers for in the first place, as well as how we might acquire them by classical means. 
					</p>

					<p>
						Random numbers, or more often pseudo-random numbers, are a necessity in modern secure communication schemes. The creation of session keys in TLS, secure Wi-Fi connections over WPA2, reliable SSH connections, and even basic plaintext encryption rely deeply on our ability to generate random numbers. These are just a few of the use-cases, but these cases alone are enough to illustrate the drastic importance of random numbers, and random-number generation.  
					</p>

					<p>
						But how do you generate a random number, and what does it mean to do that? And what exactly does it mean to have a random number generated securely- how do we know the result is secure, that there is no process to reverse the output to find the "seed number"- the initial input?
					</p>

					<p>
						In short, you often don't have an absolutely fool-proof way of making sure things are totally secure- and for almost every use-case, that's totally fine. The sheer scale of computing power necessary to crack a "cryptographically secure" pseudo-random number generating scheme is usually so absurdly high that it makes it impractical for most adversaries, including ones with very large amounts of resources at their disposal, to take the time to compromise. There are specific cryptographically-secure pseudo-random number generators (CSPRNG's) that are industry standards, though the way seeds are determined is often still a classical, and technically deterministic process.
					</p>

					<p>
						My personal favourite of these classical processes involves something called a "hardware RNG". A device that measures something physical and uses that measurement to seed the random number generation. For example, thermal noise in a chip may be used, and the stochastic process are generally unpredictable in a deterministic way that is indistindistinguishable from true randomness. That is not to say that truly ingenious hackers might not be able to create conditions in which they can expect only a small number of possible seeds and thus reverse the process, but with sufficient care the user should be able to protect against attack with only a small amount of comparative effort. Unfortunately hardware RNG's tend to deteriorate over time, becoming less and less random. 
					</p>

					<p>
						Right. So here's where we get a little picky. While CSPRNG's are outstanding for most purposes, they still have their own vulnerabilities- they may be implemented improperly, they may break down, they may distributed by <a href = "https://www.reuters.com/article/us-usa-security-rsa/exclusive-secret-contract-tied-nsa-and-security-industry-pioneer-idUSBRE9BJ1C220131220">untrustworthy vendors</a>, or any other such problem. While not wholly invulnerable, some implementations of QRNG's can address these issues. Furthermore, they are, in principal, verifiably random numbers- for those who cannot afford to trust a third-party vendor's CSPRN. The number of use cases in which one would prefer the expense of a dedicated QRNG to a cheaper, reliable CSPRNG is small. But to those users, the extra assurance is of critical importance.
					</p>

					<p>
						QRNG's work by using randomness not generated by an algorithm, but by using properties of nature. Using a prepared superposition of states, one has the opportunity to make a measurement (or many measurements) that will give a random output with some probability. It is not necessary that these probabilities be uniform, as one may use Von Neumann's trick to balance the results (as long as the bias remains fixed). For a two-level system, it is straightforward to convert multiple measurements into a binary string: one result representing a 0 and the other a 1. Doing this a number of times gives a long binary string, which may easily be converted into a decimal representation should that be desirable. This works as an effective seed, in a theoretical setting. But how can you actually implement such a device? 
					</p>

					<p>
						There are a few different ideas here: one could use a <a href = https://en.wikipedia.org/wiki/Stern%E2%80%93Gerlach_experiment>Stern-Gerlach experiment</a> (in which ions are seperated by their spins) as a way of generating their numbers, if they have such a device at their exposal. Such devices would be rather difficult to maintain and are impractical to utilise, not to mention sheerly expensive. One might also attempt a type of tunneling device- described by <a href = "https://arxiv.org/abs/1711.01752">Zhou et. al.</a>, the scheme measures whether or not a tunelling event occurs after prodding a potential well with a periodic voltage, measuring tunneling events as 1 and a lack of such events as 0. Post-processing of these seeds render viable random numbers. This kind of device seems more viable for consumer electronics to me, as it's a little easier to make such a well on a nano-scale and implement it than it is to make a miniture Stern-Gerlach experiment. There are plenty of other interesting implementation schemes, another popular type using light-polarizing beamsplitters, with much the same idea (and similar limitations) as the Stern-Gerlach apparatus in terms of applicability to consumer electronics. These devices all count on the user trusting the manufacturer, short of developing the devices themselves. We designate devices of this type, the kind available on the market for purchase today, as "trusted" QRNG's.
					 </p>
					 
					 <p>
						So are there devices that allow for self-testing, to be sure there is no tampering from the originator? Well, yes and no. There are devices that allow for self-testing to ensure perfect randomness and total security, but they require random seeds to start with. That means you either need to trust the manufacturer or build one of the QRNG's above to generate your own number, each time you want to generate a new random number. These self-testing QRNG's are also generally much slower and unable to compete in a practical way with the speed at which classical or trusted QRNG's can operate- in fact, they're blown out of the water, by a factor of more than 2 billion to one. The tradeoff is that self-testing QRNG's deliver randomness that does not depend on the implementation of the device in question, and that they do offer total security <a href = "https://www.researchgate.net/publication/43148427_Random_Numbers_Certified_by_Bell's_Theorem">guaranteed against classical adversaries</a>, hinging mostly on violation of the <a href = "https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.23.880">CHSH inequality</a> that can only be gleaned by entanglement influencing the outcome of the experiments.
					 </p>

					 <p>
						So what does all this mean? First and foremost, it means that quantum technologies have quite a way to go- but that's not necessarily a bad thing. Being able to get in on the ground floor of development of new technologies is an exciting position to be in for many reasons, not the least of which is that the position gives one the opportunity to make lasting contributions to the field. It also means that, having many (though not all) of the fundamentals worked out means that ground is broken in quantum technologies. Thus further development should be expected, not just in RNG's, but in quantum tech in general. 
					 </p>

					 <p>
						If this new technology is a sign of things to come, it's going to mean the world will need all sorts of new communication schemes, new facilities, new research, and new infrastructure to handle these fundamental changes. It will likely also necessitate shifts in public policy, in governance and corporate regulation, and in distribution of the technology. No technology, no matter how mundane or innocuous it seems, is divorced from the dynamics of power. It bears keeping that in mind. It will be incumbant on those with the wherewithal to use these new technologies to do so in a responsible manner.
					 </p>
=======
					<h1>Bolzano-Weierstrass without a ruler</h1>
				</a>
				<hr>
				<div class="in-content">
					<p> 
						The <a href = https://en.wikipedia.org/wiki/Bolzano%E2%80%93Weierstrass_theorem> Bolzano-Weierstrass theorem</a> is often thought of as a critical piece of elementary education in real analysis. While its criticality is not up for debate, at least with me, its position as a theorem of real analysis certainly is! In fact, it is possible to derive the theorem by shear topological methods, and with a little help from a base idea of functional analysis- no metric required. 
					</p>

					<p>
						Ordinarily, the theorem is stated as the result that a sequence is compact (read: <a href=https://en.wikipedia.org/wiki/Sequentially_compact_space>sequentially compact</a>) iff it is closed and bounded. This, however, is not an appropriate statement on a generalized topological space which, while closed in many cases, does not offer a solid interpretation of boundedness (in particular, there is no concept of a "ball" in a general topological space, just neighbourhoods- which may be infinite). That means we're going to have to get a little creative. An alternative formulation to the above is the following, as presented in Wald's <i>General Relativity</i>:
					</p>

					<p>
						<b>Theorem: Balzano-Weierstrass - </b> <i>Let $(X, \mathscr{T})$ be a topological space and let $A \subset X$. If $A$ is compact, then every sequence $\{x_n\}$ of points in $A$ has an accumulation point lying in $A$. Conversely, if $(X, \mathscr{T})$ is second-countable, and every sequence in $A$ has an accumulation point in $A$, then $A$ is compact. Thus, if $(X, \mathscr{T})$ is second-countable, $A$ is compact if and only if every sequence in $A$ has a convergent subsequence whose limit lies in $A$.</i>
					</p>

					<p>
						For the uninitiated, there's quite a lot to unpack here. There are handy resources online for learning what all of these terms mean, and I encourage the reader to read those if they seek great detail. I will go over some of these definitions in brief. I am going to assume a passing familiarity with topology, and thus a pre-existing understanding of compactness and the properties of topological spaces. 
					</p>

					<p>
						We call a point $y$ an <i>accumulation point</i> or <i>limit point</i> of a sequence $\{x_n\}$ if any neighbourhood of $y$ contains an infinite number of points contained in $\{x_n\}$. As every neighbourhood of the limit itself contains the limit, the limit is automatically an accumulation point. It is not guaranteed in general that every accumulation point $y$ has a subsequence $\{y_n\}$ of $\{x_n\}$ such that $\{y_n\}$ converges to $y$, though it is possible if the space where these sequences lie is <i>first-countable</i>, which we define below.  
					</p>

					<p>
						A topological space $(X, \mathscr{T})$ is called <i>second-countable</i> if every open set in $X$ is expressible as a union of open sets from some countable set of open sets. i.e. where $A$, $\mathcal{O}_\alpha$ are open sets, $$ \forall A \subset X, A = \bigcup\limits_\alpha \mathcal{O}_\alpha$$ In this way, it is easy to see that second-countability implies first-countability, which is the notion that every point in $X$ is contained in at least one of a countable collection of open sets. 
					</p>

					<p>
						With the bookkeeping out of the way, we get to the proof of the theorem. It goes like this- we start in the forward direction: if $A$ is compact, then the sequences $\{x_n\}$ in $A$ have accumulation points in $A$. The definition of compactness of a set is that any open covering of that set must admit a finite subcovering. We attempt a proof by contradicton, in that we start with a comapct set set in which the seqeunces do not have accumulation points in the set. It is our hope that this leads to a regime in which $A$ cannot be compact, thus invalidating the assumption. 
					</p>

					<p>
						for each $a \in A$, we choose an open set $\mathcal{U}_a$ containing $a$ such that a sequence $\{x_n\}$ contains a finite amount of points in $\mathcal{U}_a$. $\{\mathcal{U}_a | a \in A \}$ is an open cover of $A$, namely the set $\{ \mathcal{U}_{a_1}, \ldots , \mathcal{U}_{a_n} \}$. However, if $\{ \mathcal{U}_{a_1}, \ldots , \mathcal{U}_{a_n} \}$ is an open cover, $\{x_n \} \subset \{ \mathcal{U}_{a_1}, \ldots , \mathcal{U}_{a_n} \}$. Then some $\mathcal{U}_{a_i}\}$ in $\{ \mathcal{U}_{a_1}, \ldots , \mathcal{U}_{a_n} \}$ contains infinitely many points of $\{x_n\}$  as the sequence $\{x_n\}$ is infinite. A contradiction! If there are to be finitely many sets covering $A$, these sets must contain accumulation points.
					</p>
					
					<p>
						Ok, so that's step one. The second step is considerably more involved. We aim to prove that if $(X,\mathscr{T})$ is 2nd-countable, and if every sequence $\{x_n\}$ in $A$ has an accumulation point in $A$, that $A$ is compact. This will be done directly, though we will invoke an idea from a hitherto-unused part of mathematics. Don't worry, it's straightforward. 
					</p>

					<p>
						First- if  $(X,\mathscr{T})$ is 2nd-countable, it is first countable and that guarantees that every convergent sequence in  $(X,\mathscr{T})$ has convergent subsequences- i.e. every accumulation point $y$ of a sequence $\{x_n\}$ may be written as the limit of a sequence $\{y_n\}$ such that $\{y_n\} \subset  \{x_n\}$. Thus for what it's worth, we can say that the set $A$ is closed, as $A = \overline{A}$. 
					</p>

					<p>
						Now we need the concept of "nets", from functional analysis. A "net" is a function taking a "directional set" to a topological space. A directional set is a set with an implicit ordering, like the integers. As an example case, we say $A$ is a set with an index set on the elements of $A$, $\{n,n-1,\ldots,1\}$, such that elements follow the relation according to their index: $a_n \geq a_{n-1} \geq \ldots \geq a_1$. That is, in plain english, the last element is greater than or equal to the second-last, and so-on until you reach the terminal element, if applicable. 
					</p>

					<p>
						Say a net $\{X_{\lambda}\}_{\lambda \in \Lambda}$ has a "cluster point" $x$ if for every neighbourhood $\mathcal{O}$ of $X$ the index set $\{\lambda : X_{\lambda} \in \mathcal{O}\}$ is cofinal in $\Lambda$. $x$ is a cluster point of the net $\{X_{\lambda}\}_{\lambda \in \Lambda}$ iff some subset $\{X_{\gamma}\}_{\gamma \in \Gamma}$ converges to $x$. $x$ is an accumulation point of $A$ iff $\exists$ a net $X \notin \{X_{\lambda}\}_{\lambda \in \Lambda} \subset A$ that converges to $x$. $x \in X$ is an accumulation point of $A$ if $\mathcal{O}(x)$ contains infinitely many limit points. We have a lemma to prove:
					</p>

					<p>
						<b>Lemma:</b> <i>$A \subset X$ is countably compact iff every infinite subset has a limit point iff every sequence has a cluster point.</i> <br> We start with the last point: let $K$ be an infinite set, and suppose every sequence has a cluster point. Clearly, we may construct a sequence in $K$ such that its cluster point is a limit point in $K$. Now on the other hand, suppose that any infinite subset has an accumulation point.  We take some infinite subset $k \in K$ : consider any distinct sequence $\{x_n\}$ with distinct elements. Any of these elements is a cluster point. <br> Now suppose $X$ is compact. Let $\{x_n\}$ be a sequence in $X$ and say $B_n = \overline{\{x_i\}}_{i=n}^{\infty}$ so that $\exists x \in \cap_{n=1}^{\infty}B_n$. Any neighbourhood of $x$, say $\mathcal{O}$, intersects infinitely many points of  $\{x_n\}$ as otherwise $\cap_{n=1}^{\infty}B_n = \emptyset$. On the other hand, suppose every sequence has a cluster point, and let $B_n$ be a sequence of closed sets such that they satisfy the property of finite intersections. We choose any $x_n \in B_1 \cap \ldots \cap B_n$. Any cluster point of $\{x_n\}$, like $x$, is therefore in $\cap_{n=1}^{\infty}B_n$. 
					</p>

					<p>
						From our construction, we know that countable compactness implies limit point compactness, and due to first-countability, vice-versa. Due to second-countability, we know that every open covering must be made up of a countable union of open sets from some countable set of open sets- thus countable compactness implies compactness. This only works because our space is countable! Were it not for that fact, one might take some uncountable open covering of $X$ which would admit no finite subcovering. This acknowledgement concludes the proof. 
					</p>

>>>>>>> 793e8366799596d2b451d90fc4e6a01e43786cf8
				</div>
			</div>
		</div>
	</div>

	<footer>
		<div class="container">
			<div class="units-row">
			    <div class="unit-100">
					<ul class="social list-flat right">
						<li><a href="mailto:will.gertler@gmail.com"><i class="fa fa-send"></i></a></li>
						<li><a href="http://twitter.com/swickrotation"><i class="fa fa-twitter"></i></a></li>
						<li><a href="https://www.linkedin.com/in/william-gertler-7a965375/"><i class="fa fa-linkedin"></i></a></li>
					</ul>
				</div>
			</div>
		</div>
	</footer>

	<!-- Javascript -->
	<script src="js/jquery.min.js"></script>
    <script src="js/kube.min.js"></script>
</body>
</html>